{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Stupid Simple IDL \u00b6 The Djinni-IDL provides a simple, yet powerful way to design your interfaces. IDE Integration \u00b6 Plugins for the Djinni IDL are available for IntelliJ IDEA & VS Code Ready for the Future \u00b6 Djinni is also compatible with modern technologies. Call your C++ Code from Kotlin and Swift to have even more fun!","title":"Djinni"},{"location":"#stupid-simple-idl","text":"The Djinni-IDL provides a simple, yet powerful way to design your interfaces.","title":"Stupid Simple IDL"},{"location":"#ide-integration","text":"Plugins for the Djinni IDL are available for IntelliJ IDEA & VS Code","title":"IDE Integration"},{"location":"#ready-for-the-future","text":"Djinni is also compatible with modern technologies. Call your C++ Code from Kotlin and Swift to have even more fun!","title":"Ready for the Future"},{"location":"example/","text":"Example \u00b6 breakdown of simple example with android/ios?","title":"Example"},{"location":"example/#example","text":"breakdown of simple example with android/ios?","title":"Example"},{"location":"icon_resources/","text":"Resources \u00b6 Icon \u00b6 Affinity Designer Resource file","title":"Icon"},{"location":"icon_resources/#resources","text":"","title":"Resources"},{"location":"icon_resources/#icon","text":"Affinity Designer Resource file","title":"Icon"},{"location":"overview/","text":"Overview \u00b6 What is djinni? \u00b6 Djinni is a tool for generating cross-language type declarations and interface bindings. It's designed to connect C++ with either Java or Objective-C. Djinni can be used to interface cross-platform C++ library code with platform-specific Java and Objective-C on Android and iOS. Dropbox announced Djinni at CppCon 2014. Djinni \u2764\ufe0f Community! Dropbox ended maintenance of Djinni in March 2020. This fork wants to give Djinni a second life by transforming it to a community-driven project. We are currently in the early stage of migration to the all new cross-language-cpp organization. Everybody interested in helping us to form this new place is more than welcome! Main Features \u00b6 Generates parallel C++, Java and Objective-C type definitions from a single interface description file. Supports the intersection of the three core languages' primitive types, and user-defined enums, records, and interfaces. Generates interface code allowing bidirectional calls between C++ and Java (with JNI) or Objective-C (with Objective-C++). Can autogenerate comparator functions (equality, ordering) on data types. Components of Djinni \u00b6 Djinni consists of 2 important components: Generator : Takes a Djinni-IDL file as input and generates the gluecode. Support lib : Library that is required for the gluecode to work. How the magic works \u00b6 To call from one programming language to another, usually a lot of gluecode is required. Djinni automatically generates this gluecode from in interface file. All you need to do is implement the interfaces generated by djinni in one language and use it from the other language. Djinni takes care of the heavy lifting: Converting data-types, managing pointers and freeing memory. Call C++ Code from Java or Objective-C \u00b6 This Djinni Interface defines a class that is implemented in C++ and can be called from Java or Objective-C: HelloWorld = interface +c { static init(): HelloWorld; fromCpp(): string } Implemented in C++ #include \"djinni/generated/HelloWorld.hpp\" class HelloWorldImpl : public HelloWorld { public : static std :: shared_ptr < HelloWorld > create () { return std :: make_shared < HelloWorldImpl > (); } std :: string fromCpp () { return \"Hello From C++!\" ; } } Called from Java HelloWorld helloWorld = HelloWorld . create (); System . out . println ( helloWorld . fromCpp ()); // Hello from C++! or Objective-C HelloWorld * helloWorld = [ HelloWorld create ]; NSLog ([ helloWorld fromCpp ]); // Hello from C++! Call Java/Objective-C Code from C++ \u00b6 This Djinni interface can be implemented in either Java or Objective-C, and can be called from C++: HelloWorld = interface +j +o { fromLanguage(): string; } Implemented in Java public class HelloWorldJava extends HelloWorld { @Override String fromLanguage () { return \"from Java\" ; } } or Objective-C @interface HelloWorldObjC : NSObject < HelloWorld > - ( NSString ) fromLanguage ; @end @implementation HelloWorldObjC - ( NSString ) fromLanguage { return \"from Objective-C\" ; } @end Called from C++ std :: cout << helloWorldInstance -> fromLanguage () << std :: endl ;","title":"Overview"},{"location":"overview/#overview","text":"","title":"Overview"},{"location":"overview/#what-is-djinni","text":"Djinni is a tool for generating cross-language type declarations and interface bindings. It's designed to connect C++ with either Java or Objective-C. Djinni can be used to interface cross-platform C++ library code with platform-specific Java and Objective-C on Android and iOS. Dropbox announced Djinni at CppCon 2014. Djinni \u2764\ufe0f Community! Dropbox ended maintenance of Djinni in March 2020. This fork wants to give Djinni a second life by transforming it to a community-driven project. We are currently in the early stage of migration to the all new cross-language-cpp organization. Everybody interested in helping us to form this new place is more than welcome!","title":"What is djinni?"},{"location":"overview/#main-features","text":"Generates parallel C++, Java and Objective-C type definitions from a single interface description file. Supports the intersection of the three core languages' primitive types, and user-defined enums, records, and interfaces. Generates interface code allowing bidirectional calls between C++ and Java (with JNI) or Objective-C (with Objective-C++). Can autogenerate comparator functions (equality, ordering) on data types.","title":"Main Features"},{"location":"overview/#components-of-djinni","text":"Djinni consists of 2 important components: Generator : Takes a Djinni-IDL file as input and generates the gluecode. Support lib : Library that is required for the gluecode to work.","title":"Components of Djinni"},{"location":"overview/#how-the-magic-works","text":"To call from one programming language to another, usually a lot of gluecode is required. Djinni automatically generates this gluecode from in interface file. All you need to do is implement the interfaces generated by djinni in one language and use it from the other language. Djinni takes care of the heavy lifting: Converting data-types, managing pointers and freeing memory.","title":"How the magic works"},{"location":"overview/#call-c-code-from-java-or-objective-c","text":"This Djinni Interface defines a class that is implemented in C++ and can be called from Java or Objective-C: HelloWorld = interface +c { static init(): HelloWorld; fromCpp(): string } Implemented in C++ #include \"djinni/generated/HelloWorld.hpp\" class HelloWorldImpl : public HelloWorld { public : static std :: shared_ptr < HelloWorld > create () { return std :: make_shared < HelloWorldImpl > (); } std :: string fromCpp () { return \"Hello From C++!\" ; } } Called from Java HelloWorld helloWorld = HelloWorld . create (); System . out . println ( helloWorld . fromCpp ()); // Hello from C++! or Objective-C HelloWorld * helloWorld = [ HelloWorld create ]; NSLog ([ helloWorld fromCpp ]); // Hello from C++!","title":"Call C++ Code from Java or Objective-C"},{"location":"overview/#call-javaobjective-c-code-from-c","text":"This Djinni interface can be implemented in either Java or Objective-C, and can be called from C++: HelloWorld = interface +j +o { fromLanguage(): string; } Implemented in Java public class HelloWorldJava extends HelloWorld { @Override String fromLanguage () { return \"from Java\" ; } } or Objective-C @interface HelloWorldObjC : NSObject < HelloWorld > - ( NSString ) fromLanguage ; @end @implementation HelloWorldObjC - ( NSString ) fromLanguage { return \"from Objective-C\" ; } @end Called from C++ std :: cout << helloWorldInstance -> fromLanguage () << std :: endl ;","title":"Call Java/Objective-C Code from C++"},{"location":"setup/","text":"Setup \u00b6 The following steps are required to get you started: Installation of djinni-generator \u00b6 TODO Install IDE Plugin \u00b6 TODO Add the support-lib to your project \u00b6 TODO","title":"Setup"},{"location":"setup/#setup","text":"The following steps are required to get you started:","title":"Setup"},{"location":"setup/#installation-of-djinni-generator","text":"TODO","title":"Installation of djinni-generator"},{"location":"setup/#install-ide-plugin","text":"TODO","title":"Install IDE Plugin"},{"location":"setup/#add-the-support-lib-to-your-project","text":"TODO","title":"Add the support-lib to your project"},{"location":"djinni-generator/developer-docs/","text":"Developer Docs \u00b6 Information that may be interesting for you if you want to help improve djinni generator.","title":"Developer Docs"},{"location":"djinni-generator/developer-docs/#developer-docs","text":"Information that may be interesting for you if you want to help improve djinni generator.","title":"Developer Docs"},{"location":"djinni-generator/idl/","text":"Interface Definition Language \u00b6 Djinni's input is an interface description file. Here's an example: # Multi-line comments can be added here. This comment will be propagated # to each generated definition. my_enum = enum { option1; option2; option3; } my_flags = flags { flag1; flag2; flag3; no_flags = none; all_flags = all; } my_record = record { id: i32; info: string; store: set<string>; hash: map<string, i32>; values: list<another_record>; # Comments can also be put here # Constants can be included const string_const: string = \"Constants can be put here\"; const min_value: another_record = { key1 = 0, key2 = \"\" }; } another_record = record { key1: i32; key2: string; } deriving (eq, ord) # This interface will be implemented in C++ and can be called from any language. my_cpp_interface = interface +c { method_returning_nothing(value: i32); method_returning_some_type(key: string): another_record; static get_version(): i32; # Interfaces can also have constants const version: i32 = 1; } # This interface will be implemented in Java and ObjC and can be called from C++. my_client_interface = interface +j +o { log_string(str: string): bool; } Djinni files can also include each other. Adding the line: @import \"relative/path/to/filename.djinni\" at the beginning of a file will simply include another file. Child file paths are relative to the location of the file that contains the @import. Two different djinni files cannot define the same type. @import behaves like #include with #pragma once in C++, or like ObjC's #import : if a file is included multiple times through different paths, then it will only be processed once. Data Types \u00b6 The available data types for a record, argument, or return value are: Boolean ( bool ) Primitives ( i8 , i16 , i32 , i64 , f32 , f64 ). Strings ( string ) Binary ( binary ). This is implemented as std::vector<uint8_t> in C++, byte[] in Java, and NSData in Objective-C. Date ( date ). This is chrono::system_clock::time_point in C++, Date in Java, and NSDate in Objective-C. List ( list<type> ). This is vector<T> in C++, ArrayList in Java, and NSArray in Objective-C. Primitives in a list will be boxed in Java and Objective-C. Set ( set<type> ). This is unordered_set<T> in C++, HashSet in Java, and NSSet in Objective-C. Primitives in a set will be boxed in Java and Objective-C. Map ( map<typeA, typeB> ). This is unordered_map<K, V> in C++, HashMap in Java, and NSDictionary in Objective-C. Primitives in a map will be boxed in Java and Objective-C. Enumerations / Flags Optionals ( optional<typeA> ). This is std::experimental::optional<T> in C++11, object / boxed primitive reference in Java (which can be null ), and object / NSNumber strong reference in Objective-C (which can be nil ). Other record types. This is generated with a by-value semantic, i.e. the copy method will deep-copy the contents. Types \u00b6 An IDL file can contain 4 kinds of declarations: enums, flags, records, and interfaces. Enums become C++ enum classes, Java enums, or ObjC NS_ENUM s. Flags become C++ enum classes with convenient bit-oriented operators, Java enums with EnumSet , or ObjC NS_OPTIONS . Records are pure-data value objects. Interfaces are objects with defined methods to call (in C++, passed by shared_ptr ). Djinni produces code allowing an interface implemented in C++ to be transparently used from ObjC or Java, and vice versa. Enums \u00b6 my_enum = enum { option1; option2; option3; } Enums are translated to C++ enum class es with underlying type int , ObjC NS_ENUM s with underlying type NSInteger , and Java enums. Flags \u00b6 my_flags = flags { flag1; flag2; flag3; no_flags = none; all_flags = all; } Flags are translated to C++ enum class es with underlying type unsigned and a generated set of overloaded bitwise operators for convenience, ObjC NS_OPTIONS with underlying type NSUInteger , and Java EnumSet<> . Contrary to the above enums, the enumerants of flags represent single bits instead of integral values. In the above example the elements marked with none and all are given special meaning. In C++ and ObjC the no_flags option is generated with a value that has no bits set (i.e. 0 ), and all_flags is generated as a bitwise-or combination of all other values. In Java these special options are not generated as one can just use EnumSet.noneOf() and EnumSet.allOf() . Records \u00b6 my_record = record { id: i32; info: string; store: set<string>; hash: map<string, i32>; values: list<another_record>; # Comments can also be put here # Constants can be included const string_const: string = \"Constants can be put here\"; const min_value: another_record = { key1 = 0, key2 = \"\" }; } Records are data objects. In C++, records contain all their elements by value, including other records (so a record cannot contain itself). Extensions \u00b6 To support extra fields and/or methods, a record can be \"extended\" in any language. To extend a record in a language, you can add a +c (C++), +j (Java), or +o (ObjC) flag after the record tag. The generated type will have a Base suffix, and you should create a derived type without the suffix that extends the record type. The derived type must be constructible in the same way as the Base type. Interfaces will always use the derived type. Derived methods \u00b6 another_record = record { key1: i32; key2: string; } deriving (eq, ord) For record types, Haskell-style \"deriving\" declarations are supported to generate some common methods. Djinni is capable of generating equality and order comparators, implemented as operator overloading in C++ and standard comparison functions in Java / Objective-C. Note All fields in the record are compared in the order they appear in the record declaration. If you need to add a field later, make sure the order is correct. Ordering comparison is not supported for collection types, optionals, and booleans. To compare records containing other records, the inner record must derive at least the same types of comparators as the outer record. Interfaces \u00b6 # This interface will be implemented in C++ and can be called from any language. my_cpp_interface = interface +c { method_returning_nothing(value: i32); method_returning_some_type(key: string): another_record; static get_version(): i32; # Interfaces can also have constants const version: i32 = 1; } # This interface will be implemented in Java and ObjC and can be called from C++. my_client_interface = interface +j +o { log_string(str: string): bool; } Interfaces are objects with defined methods to call (in C++, passed by shared_ptr ). Djinni produces code allowing an interface implemented in C++ to be transparently used from ObjC or Java, and vice versa. Special Methods for C++ Only \u00b6 +c interfaces (implementable only in C++) can have methods flagged with the special keywords const and static which have special effects in C++: special_methods = interface +c { const accessor_method(); static factory_method(); } const methods will be declared as const in C++, though this cannot be enforced on callers in other languages, which lack this feature. static methods will become a static method of the C++ class, which can be called from other languages without an object. This is often useful for factory methods to act as a cross-language constructor. Exception Handling \u00b6 When an interface implemented in C++ throws a std::exception , it will be translated to a java.lang.RuntimeException in Java or an NSException in Objective-C. The what() message will be translated as well. Constants \u00b6 Constants can be defined within interfaces and records. In Java and C++ they are part of the generated class; and in Objective-C, constant names are globals with the name of the interface/record prefixed. Example: record_with_const = record +c +j +o { const const_value: i32 = 8; } will be RecordWithConst::CONST_VALUE in C++, RecordWithConst.CONST_VALUE in Java, and RecordWithConstConstValue in Objective-C.","title":"Interface Definition Language"},{"location":"djinni-generator/idl/#interface-definition-language","text":"Djinni's input is an interface description file. Here's an example: # Multi-line comments can be added here. This comment will be propagated # to each generated definition. my_enum = enum { option1; option2; option3; } my_flags = flags { flag1; flag2; flag3; no_flags = none; all_flags = all; } my_record = record { id: i32; info: string; store: set<string>; hash: map<string, i32>; values: list<another_record>; # Comments can also be put here # Constants can be included const string_const: string = \"Constants can be put here\"; const min_value: another_record = { key1 = 0, key2 = \"\" }; } another_record = record { key1: i32; key2: string; } deriving (eq, ord) # This interface will be implemented in C++ and can be called from any language. my_cpp_interface = interface +c { method_returning_nothing(value: i32); method_returning_some_type(key: string): another_record; static get_version(): i32; # Interfaces can also have constants const version: i32 = 1; } # This interface will be implemented in Java and ObjC and can be called from C++. my_client_interface = interface +j +o { log_string(str: string): bool; } Djinni files can also include each other. Adding the line: @import \"relative/path/to/filename.djinni\" at the beginning of a file will simply include another file. Child file paths are relative to the location of the file that contains the @import. Two different djinni files cannot define the same type. @import behaves like #include with #pragma once in C++, or like ObjC's #import : if a file is included multiple times through different paths, then it will only be processed once.","title":"Interface Definition Language"},{"location":"djinni-generator/idl/#data-types","text":"The available data types for a record, argument, or return value are: Boolean ( bool ) Primitives ( i8 , i16 , i32 , i64 , f32 , f64 ). Strings ( string ) Binary ( binary ). This is implemented as std::vector<uint8_t> in C++, byte[] in Java, and NSData in Objective-C. Date ( date ). This is chrono::system_clock::time_point in C++, Date in Java, and NSDate in Objective-C. List ( list<type> ). This is vector<T> in C++, ArrayList in Java, and NSArray in Objective-C. Primitives in a list will be boxed in Java and Objective-C. Set ( set<type> ). This is unordered_set<T> in C++, HashSet in Java, and NSSet in Objective-C. Primitives in a set will be boxed in Java and Objective-C. Map ( map<typeA, typeB> ). This is unordered_map<K, V> in C++, HashMap in Java, and NSDictionary in Objective-C. Primitives in a map will be boxed in Java and Objective-C. Enumerations / Flags Optionals ( optional<typeA> ). This is std::experimental::optional<T> in C++11, object / boxed primitive reference in Java (which can be null ), and object / NSNumber strong reference in Objective-C (which can be nil ). Other record types. This is generated with a by-value semantic, i.e. the copy method will deep-copy the contents.","title":"Data Types"},{"location":"djinni-generator/idl/#types","text":"An IDL file can contain 4 kinds of declarations: enums, flags, records, and interfaces. Enums become C++ enum classes, Java enums, or ObjC NS_ENUM s. Flags become C++ enum classes with convenient bit-oriented operators, Java enums with EnumSet , or ObjC NS_OPTIONS . Records are pure-data value objects. Interfaces are objects with defined methods to call (in C++, passed by shared_ptr ). Djinni produces code allowing an interface implemented in C++ to be transparently used from ObjC or Java, and vice versa.","title":"Types"},{"location":"djinni-generator/idl/#enums","text":"my_enum = enum { option1; option2; option3; } Enums are translated to C++ enum class es with underlying type int , ObjC NS_ENUM s with underlying type NSInteger , and Java enums.","title":"Enums"},{"location":"djinni-generator/idl/#flags","text":"my_flags = flags { flag1; flag2; flag3; no_flags = none; all_flags = all; } Flags are translated to C++ enum class es with underlying type unsigned and a generated set of overloaded bitwise operators for convenience, ObjC NS_OPTIONS with underlying type NSUInteger , and Java EnumSet<> . Contrary to the above enums, the enumerants of flags represent single bits instead of integral values. In the above example the elements marked with none and all are given special meaning. In C++ and ObjC the no_flags option is generated with a value that has no bits set (i.e. 0 ), and all_flags is generated as a bitwise-or combination of all other values. In Java these special options are not generated as one can just use EnumSet.noneOf() and EnumSet.allOf() .","title":"Flags"},{"location":"djinni-generator/idl/#records","text":"my_record = record { id: i32; info: string; store: set<string>; hash: map<string, i32>; values: list<another_record>; # Comments can also be put here # Constants can be included const string_const: string = \"Constants can be put here\"; const min_value: another_record = { key1 = 0, key2 = \"\" }; } Records are data objects. In C++, records contain all their elements by value, including other records (so a record cannot contain itself).","title":"Records"},{"location":"djinni-generator/idl/#extensions","text":"To support extra fields and/or methods, a record can be \"extended\" in any language. To extend a record in a language, you can add a +c (C++), +j (Java), or +o (ObjC) flag after the record tag. The generated type will have a Base suffix, and you should create a derived type without the suffix that extends the record type. The derived type must be constructible in the same way as the Base type. Interfaces will always use the derived type.","title":"Extensions"},{"location":"djinni-generator/idl/#derived-methods","text":"another_record = record { key1: i32; key2: string; } deriving (eq, ord) For record types, Haskell-style \"deriving\" declarations are supported to generate some common methods. Djinni is capable of generating equality and order comparators, implemented as operator overloading in C++ and standard comparison functions in Java / Objective-C. Note All fields in the record are compared in the order they appear in the record declaration. If you need to add a field later, make sure the order is correct. Ordering comparison is not supported for collection types, optionals, and booleans. To compare records containing other records, the inner record must derive at least the same types of comparators as the outer record.","title":"Derived methods"},{"location":"djinni-generator/idl/#interfaces","text":"# This interface will be implemented in C++ and can be called from any language. my_cpp_interface = interface +c { method_returning_nothing(value: i32); method_returning_some_type(key: string): another_record; static get_version(): i32; # Interfaces can also have constants const version: i32 = 1; } # This interface will be implemented in Java and ObjC and can be called from C++. my_client_interface = interface +j +o { log_string(str: string): bool; } Interfaces are objects with defined methods to call (in C++, passed by shared_ptr ). Djinni produces code allowing an interface implemented in C++ to be transparently used from ObjC or Java, and vice versa.","title":"Interfaces"},{"location":"djinni-generator/idl/#special-methods-for-c-only","text":"+c interfaces (implementable only in C++) can have methods flagged with the special keywords const and static which have special effects in C++: special_methods = interface +c { const accessor_method(); static factory_method(); } const methods will be declared as const in C++, though this cannot be enforced on callers in other languages, which lack this feature. static methods will become a static method of the C++ class, which can be called from other languages without an object. This is often useful for factory methods to act as a cross-language constructor.","title":"Special Methods for C++ Only"},{"location":"djinni-generator/idl/#exception-handling","text":"When an interface implemented in C++ throws a std::exception , it will be translated to a java.lang.RuntimeException in Java or an NSException in Objective-C. The what() message will be translated as well.","title":"Exception Handling"},{"location":"djinni-generator/idl/#constants","text":"Constants can be defined within interfaces and records. In Java and C++ they are part of the generated class; and in Objective-C, constant names are globals with the name of the interface/record prefixed. Example: record_with_const = record +c +j +o { const const_value: i32 = 8; } will be RecordWithConst::CONST_VALUE in C++, RecordWithConst.CONST_VALUE in Java, and RecordWithConstConstValue in Objective-C.","title":"Constants"},{"location":"djinni-generator/setup/","text":"Generator Setup \u00b6 Installation \u00b6 Important The generator requires Java ! Linux, macOS Download the lastest released binary , make it executable and put the containing folder on your PATH: curl -LO https://github.com/cross-language-cpp/djinni-generator/releases/latest/download/djinni chmod u+x djinni export PATH = $( pwd ) : $PATH Make sure to put it on your PATH permanently once you fell in love with djinni! Windows Download the latest released batch file , copy it where you want and put the folder on your PATH .","title":"Generator Setup"},{"location":"djinni-generator/setup/#generator-setup","text":"","title":"Generator Setup"},{"location":"djinni-generator/setup/#installation","text":"Important The generator requires Java ! Linux, macOS Download the lastest released binary , make it executable and put the containing folder on your PATH: curl -LO https://github.com/cross-language-cpp/djinni-generator/releases/latest/download/djinni chmod u+x djinni export PATH = $( pwd ) : $PATH Make sure to put it on your PATH permanently once you fell in love with djinni! Windows Download the latest released batch file , copy it where you want and put the folder on your PATH .","title":"Installation"},{"location":"djinni-generator/usage/","text":"Using the Generator \u00b6 When the Djinni file(s) are ready, from the command line or a bash script you can run: djinni \\ --java-out JAVA_OUTPUT_FOLDER \\ --java-package com.example.jnigenpackage \\ --java-cpp-exception DbxException \\ # Choose between a customized C++ exception in Java and java.lang.RuntimeException (the default). --ident-java-field mFooBar \\ # Optional, this adds an \"m\" in front of Java field names \\ --cpp-out CPP_OUTPUT_FOLDER \\ \\ --jni-out JNI_OUTPUT_FOLDER \\ --ident-jni-class NativeFooBar \\ # This adds a \"Native\" prefix to JNI class --ident-jni-file NativeFooBar \\ # This adds a prefix to the JNI filenames otherwise the cpp and jni filenames are the same. \\ --objc-out OBJC_OUTPUT_FOLDER \\ --objc-type-prefix DB \\ # Apple suggests Objective-C classes have a prefix for each defined type. \\ --objcpp-out OBJC_OUTPUT_FOLDER \\ \\ --idl MY_PROJECT.djinni Some other options are also available, such as --cpp-namespace that put generated C++ code into the namespace specified. For a list of all options, run djinni --help All Arguments \u00b6 General \u00b6 Argument Description --help Print help --version Print version --idl <in-file> The IDL file with the type definitions, typically with extension .djinni . --idl-include-path <path> ... An include path to search for Djinni @import directives. Can specify multiple paths. Java \u00b6 Argument Description --java-out <out-folder> The output for the Java files (Generator disabled if unspecified). --java-package ... The package name to use for generated Java classes. --java-class-access-modifier <public/package> The access modifier to use for generated Java classes (default: public ). --java-cpp-exception <exception-class> The type for translated C++ exceptions in Java (default: java.lang.RuntimeException that is not checked) --java-annotation <annotation-class> Java annotation ( @Foo ) to place on all generated Java classes --java-generate-interfaces <true/false> Whether Java interfaces should be used instead of abstract classes where possible (default: false). --java-nullable-annotation <nullable-annotation-class> Java annotation ( @Nullable ) to place on all fields and return values that are optional --java-nonnull-annotation <nonnull-annotation-class> Java annotation ( @Nonnull ) to place on all fields and return values that are not optional --java-implement-android-os-parcelable <true/false> all generated java classes will implement the interface android.os.Parcelable --java-use-final-for-record <use-final-for-record> Whether generated Java classes for records should be marked final (default: true ). C++ \u00b6 Argument Description --cpp-out <out-folder> The output folder for C++ files (Generator disabled if unspecified). --cpp-header-out <out-folder> The output folder for C++ header files (default: the same as --cpp-out ). --cpp-include-prefix <prefix> The prefix for #includes of header files from C++ files. --cpp-namespace ... The namespace name to use for generated C++ classes. --cpp-ext <ext> The filename extension for C++ files (default: cpp ). --hpp-ext <ext> The filename extension for C++ header files (default: hpp ). --cpp-optional-template <template> The template to use for optional values (default: std::optional ) --cpp-optional-header <header> The header to use for optional values (default: <optional> ) --cpp-enum-hash-workaround <true/false> Work around LWG-2148 by generating std::hash specializations for C++ enums (default: true ) --cpp-nn-header <header> The header to use for non-nullable pointers --cpp-nn-type <header> The type to use for non-nullable pointers (as a substitute for std::shared_ptr ) --cpp-nn-check-expression <header> The expression to use for building non-nullable pointers --cpp-use-wide-strings <true/false> Use wide strings in C++ code (default: false ) JNI \u00b6 Argument Description --jni-out <out-folder> The folder for the JNI C++ output files (Generator disabled if unspecified). --jni-header-out <out-folder> The folder for the JNI C++ header files (default: the same as --jni-out ). --jni-include-prefix <prefix> The prefix for #includes of JNI header files from JNI C++ files. --jni-include-cpp-prefix <prefix> The prefix for #includes of the main header files from JNI C++ files. --jni-namespace ... The namespace name to use for generated JNI C++ classes. --jni-base-lib-include-prefix ... The JNI base library's include path, relative to the JNI C++ classes. Objective-C \u00b6 Argument Description --objc-out <out-folder> The output folder for Objective-C files (Generator disabled if unspecified). --objc-h-ext <ext> The filename extension for Objective-C[++] header files (default: h ) --objc-type-prefix <pre> The prefix for Objective-C data types (usually two or three letters) --objc-include-prefix <prefix> The prefix for #import of header files from Objective-C files. --objc-swift-bridging-header <name> The name of Objective-C Bridging Header used in XCode's Swift projects. --objc-closed-enums <true/false> All generated Objective-C enums will be NS_CLOSED_ENUM (default: false ). Objective-C++ \u00b6 Argument Description --objcpp-out <out-folder> The output folder for private Objective-C++ files (Generator disabled if unspecified). --objcpp-ext <ext> The filename extension for Objective-C++ files (default: mm ) --objcpp-include-prefix <prefix> The prefix for #import of Objective-C++ header files from Objective-C++ files. --objcpp-include-cpp-prefix <prefix> The prefix for #include of the main C++ header files from Objective-C++ files. --objcpp-include-objc-prefix <prefix> The prefix for #import of the Objective-C header files from Objective-C++ files (default: the same as --objcpp-include-prefix ) --cpp-extended-record-include-prefix <prefix> The prefix path for #include of the extended record C++ header ( .hpp ) files --objc-extended-record-include-prefix <prefix> The prefix path for #import of the extended record Objective-C header ( .h ) files --objcpp-namespace <prefix> The namespace name to use for generated Objective-C++ classes. --objc-base-lib-include-prefix ... The Objective-C++ base library's include path, relative to the Objective-C++ classes. Yaml Generation \u00b6 Argument Description --yaml-out <out-folder> The output folder for YAML files (Generator disabled if unspecified). --yaml-out-file <out-file> If specified all types are merged into a single YAML file instead of generating one file per type (relative to --yaml-out ). --yaml-prefix <pre> The prefix to add to type names stored in YAML files (default: \"\"). Other \u00b6 Argument Description --list-in-files <list-in-files> Optional file in which to write the list of input files parsed. --list-out-files <list-out-files> Optional file in which to write the list of output files produced. --skip-generation <true/false> Way of specifying if file generation should be skipped (default: false ) Identifier Style \u00b6 Identifier styles (ex: FooBar , fooBar , foo_bar , FOO_BAR , m_fooBar ) Argument --ident-java-enum ... --ident-java-field ... --ident-java-type ... --ident-cpp-enum ... --ident-cpp-field ... --ident-cpp-method ... --ident-cpp-type ... --ident-cpp-enum-type ... --ident-cpp-type-param ... --ident-cpp-local ... --ident-cpp-file ... --ident-jni-class ... --ident-jni-file ... --ident-objc-enum ... --ident-objc-field ... --ident-objc-method ... --ident-objc-type ... --ident-objc-type-param ... --ident-objc-local ... --ident-objc-file ... Note If a language's output folder is not specified, that language will not be generated. Use Generated Code in Your Project \u00b6 Java / JNI / C++ Project \u00b6 Includes & Build target \u00b6 The following headers / code will be generated for each defined type: Type C++ header C++ source Java JNI header JNI source Enum/Flags my_enum.hpp MyEnum.java NativeMyEnum.hpp NativeMyEnum.cpp Record my_record[_base].hpp my_record[_base].cpp (+) MyRecord[Base].java NativeMyRecord.hpp NativeMyRecord.cpp Interface my_interface.hpp my_interface.cpp (+) MyInterface.java NativeMyInterface.hpp NativeMyInterface.cpp (+) Generated only for types that contain constants. Add all generated source files to your build target, as well as the contents of support-lib/java . Our JNI approach \u00b6 JNI stands for Java Native Interface, an extension of the Java language to allow interop with native (C/C++) code or libraries. Complete documentation on JNI is available at: http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/jniTOC.html For each type, built-in ( list , string , etc.) or user-defined, Djinni produces a translator class with a toJava and fromJava function to translate back and forth. Application code is responsible for the initial load of the JNI library. Add a static block somewhere in your code: System.loadLibrary(\"YourLibraryName\"); // The name is specified in Android.mk / build.gradle / Makefile, depending on your build system. If you package your native library in a jar, you can also use com.dropbox.djinni.NativeLibLoader to help unpack and load your lib(s). See the Localhost README for details. When a native library is called, JNI calls a special function called JNI_OnLoad . If you use Djinni for all JNI interface code, include support_lib/jni/djinni_main.cpp ; if not, you'll need to add calls to your own JNI_OnLoad and JNI_OnUnload functions. See support-lib/jni/djinni_main.cpp for details. Objective-C / C++ Project \u00b6 Includes & Build Target \u00b6 Generated files for Objective-C / C++ are as follows (assuming prefix is DB ): Type C++ header C++ source Objective-C files Objective-C++ files Enum/Flags my_enum.hpp DBMyEnum.h Record my_record[_base].hpp my_record[_base].cpp (+) DBMyRecord[Base].h DBMyRecord[Base]+Private.h DBMyRecord[Base].mm (++) DBMyRecord[Base]+Private.mm Interface my_interface.hpp my_interface.cpp (+) DBMyInterface.h DBMyInterface+Private.h DBMyInterface+Private.mm (+) Generated only for types that contain constants. (++) Generated only for types with derived operations and/or constants. These have .mm extensions to allow non-trivial constants. Add all generated files to your build target, as well as the contents of support-lib/objc . Note that +Private files can only be used with ObjC++ source (other headers are pure ObjC) and are not required by Objective-C users of your interface.","title":"Using the Generator"},{"location":"djinni-generator/usage/#using-the-generator","text":"When the Djinni file(s) are ready, from the command line or a bash script you can run: djinni \\ --java-out JAVA_OUTPUT_FOLDER \\ --java-package com.example.jnigenpackage \\ --java-cpp-exception DbxException \\ # Choose between a customized C++ exception in Java and java.lang.RuntimeException (the default). --ident-java-field mFooBar \\ # Optional, this adds an \"m\" in front of Java field names \\ --cpp-out CPP_OUTPUT_FOLDER \\ \\ --jni-out JNI_OUTPUT_FOLDER \\ --ident-jni-class NativeFooBar \\ # This adds a \"Native\" prefix to JNI class --ident-jni-file NativeFooBar \\ # This adds a prefix to the JNI filenames otherwise the cpp and jni filenames are the same. \\ --objc-out OBJC_OUTPUT_FOLDER \\ --objc-type-prefix DB \\ # Apple suggests Objective-C classes have a prefix for each defined type. \\ --objcpp-out OBJC_OUTPUT_FOLDER \\ \\ --idl MY_PROJECT.djinni Some other options are also available, such as --cpp-namespace that put generated C++ code into the namespace specified. For a list of all options, run djinni --help","title":"Using the Generator"},{"location":"djinni-generator/usage/#all-arguments","text":"","title":"All Arguments"},{"location":"djinni-generator/usage/#general","text":"Argument Description --help Print help --version Print version --idl <in-file> The IDL file with the type definitions, typically with extension .djinni . --idl-include-path <path> ... An include path to search for Djinni @import directives. Can specify multiple paths.","title":"General"},{"location":"djinni-generator/usage/#java","text":"Argument Description --java-out <out-folder> The output for the Java files (Generator disabled if unspecified). --java-package ... The package name to use for generated Java classes. --java-class-access-modifier <public/package> The access modifier to use for generated Java classes (default: public ). --java-cpp-exception <exception-class> The type for translated C++ exceptions in Java (default: java.lang.RuntimeException that is not checked) --java-annotation <annotation-class> Java annotation ( @Foo ) to place on all generated Java classes --java-generate-interfaces <true/false> Whether Java interfaces should be used instead of abstract classes where possible (default: false). --java-nullable-annotation <nullable-annotation-class> Java annotation ( @Nullable ) to place on all fields and return values that are optional --java-nonnull-annotation <nonnull-annotation-class> Java annotation ( @Nonnull ) to place on all fields and return values that are not optional --java-implement-android-os-parcelable <true/false> all generated java classes will implement the interface android.os.Parcelable --java-use-final-for-record <use-final-for-record> Whether generated Java classes for records should be marked final (default: true ).","title":"Java"},{"location":"djinni-generator/usage/#c","text":"Argument Description --cpp-out <out-folder> The output folder for C++ files (Generator disabled if unspecified). --cpp-header-out <out-folder> The output folder for C++ header files (default: the same as --cpp-out ). --cpp-include-prefix <prefix> The prefix for #includes of header files from C++ files. --cpp-namespace ... The namespace name to use for generated C++ classes. --cpp-ext <ext> The filename extension for C++ files (default: cpp ). --hpp-ext <ext> The filename extension for C++ header files (default: hpp ). --cpp-optional-template <template> The template to use for optional values (default: std::optional ) --cpp-optional-header <header> The header to use for optional values (default: <optional> ) --cpp-enum-hash-workaround <true/false> Work around LWG-2148 by generating std::hash specializations for C++ enums (default: true ) --cpp-nn-header <header> The header to use for non-nullable pointers --cpp-nn-type <header> The type to use for non-nullable pointers (as a substitute for std::shared_ptr ) --cpp-nn-check-expression <header> The expression to use for building non-nullable pointers --cpp-use-wide-strings <true/false> Use wide strings in C++ code (default: false )","title":"C++"},{"location":"djinni-generator/usage/#jni","text":"Argument Description --jni-out <out-folder> The folder for the JNI C++ output files (Generator disabled if unspecified). --jni-header-out <out-folder> The folder for the JNI C++ header files (default: the same as --jni-out ). --jni-include-prefix <prefix> The prefix for #includes of JNI header files from JNI C++ files. --jni-include-cpp-prefix <prefix> The prefix for #includes of the main header files from JNI C++ files. --jni-namespace ... The namespace name to use for generated JNI C++ classes. --jni-base-lib-include-prefix ... The JNI base library's include path, relative to the JNI C++ classes.","title":"JNI"},{"location":"djinni-generator/usage/#objective-c","text":"Argument Description --objc-out <out-folder> The output folder for Objective-C files (Generator disabled if unspecified). --objc-h-ext <ext> The filename extension for Objective-C[++] header files (default: h ) --objc-type-prefix <pre> The prefix for Objective-C data types (usually two or three letters) --objc-include-prefix <prefix> The prefix for #import of header files from Objective-C files. --objc-swift-bridging-header <name> The name of Objective-C Bridging Header used in XCode's Swift projects. --objc-closed-enums <true/false> All generated Objective-C enums will be NS_CLOSED_ENUM (default: false ).","title":"Objective-C"},{"location":"djinni-generator/usage/#objective-c_1","text":"Argument Description --objcpp-out <out-folder> The output folder for private Objective-C++ files (Generator disabled if unspecified). --objcpp-ext <ext> The filename extension for Objective-C++ files (default: mm ) --objcpp-include-prefix <prefix> The prefix for #import of Objective-C++ header files from Objective-C++ files. --objcpp-include-cpp-prefix <prefix> The prefix for #include of the main C++ header files from Objective-C++ files. --objcpp-include-objc-prefix <prefix> The prefix for #import of the Objective-C header files from Objective-C++ files (default: the same as --objcpp-include-prefix ) --cpp-extended-record-include-prefix <prefix> The prefix path for #include of the extended record C++ header ( .hpp ) files --objc-extended-record-include-prefix <prefix> The prefix path for #import of the extended record Objective-C header ( .h ) files --objcpp-namespace <prefix> The namespace name to use for generated Objective-C++ classes. --objc-base-lib-include-prefix ... The Objective-C++ base library's include path, relative to the Objective-C++ classes.","title":"Objective-C++"},{"location":"djinni-generator/usage/#yaml-generation","text":"Argument Description --yaml-out <out-folder> The output folder for YAML files (Generator disabled if unspecified). --yaml-out-file <out-file> If specified all types are merged into a single YAML file instead of generating one file per type (relative to --yaml-out ). --yaml-prefix <pre> The prefix to add to type names stored in YAML files (default: \"\").","title":"Yaml Generation"},{"location":"djinni-generator/usage/#other","text":"Argument Description --list-in-files <list-in-files> Optional file in which to write the list of input files parsed. --list-out-files <list-out-files> Optional file in which to write the list of output files produced. --skip-generation <true/false> Way of specifying if file generation should be skipped (default: false )","title":"Other"},{"location":"djinni-generator/usage/#identifier-style","text":"Identifier styles (ex: FooBar , fooBar , foo_bar , FOO_BAR , m_fooBar ) Argument --ident-java-enum ... --ident-java-field ... --ident-java-type ... --ident-cpp-enum ... --ident-cpp-field ... --ident-cpp-method ... --ident-cpp-type ... --ident-cpp-enum-type ... --ident-cpp-type-param ... --ident-cpp-local ... --ident-cpp-file ... --ident-jni-class ... --ident-jni-file ... --ident-objc-enum ... --ident-objc-field ... --ident-objc-method ... --ident-objc-type ... --ident-objc-type-param ... --ident-objc-local ... --ident-objc-file ... Note If a language's output folder is not specified, that language will not be generated.","title":"Identifier Style"},{"location":"djinni-generator/usage/#use-generated-code-in-your-project","text":"","title":"Use Generated Code in Your Project"},{"location":"djinni-generator/usage/#java-jni-c-project","text":"","title":"Java / JNI / C++ Project"},{"location":"djinni-generator/usage/#includes-build-target","text":"The following headers / code will be generated for each defined type: Type C++ header C++ source Java JNI header JNI source Enum/Flags my_enum.hpp MyEnum.java NativeMyEnum.hpp NativeMyEnum.cpp Record my_record[_base].hpp my_record[_base].cpp (+) MyRecord[Base].java NativeMyRecord.hpp NativeMyRecord.cpp Interface my_interface.hpp my_interface.cpp (+) MyInterface.java NativeMyInterface.hpp NativeMyInterface.cpp (+) Generated only for types that contain constants. Add all generated source files to your build target, as well as the contents of support-lib/java .","title":"Includes &amp; Build target"},{"location":"djinni-generator/usage/#our-jni-approach","text":"JNI stands for Java Native Interface, an extension of the Java language to allow interop with native (C/C++) code or libraries. Complete documentation on JNI is available at: http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/jniTOC.html For each type, built-in ( list , string , etc.) or user-defined, Djinni produces a translator class with a toJava and fromJava function to translate back and forth. Application code is responsible for the initial load of the JNI library. Add a static block somewhere in your code: System.loadLibrary(\"YourLibraryName\"); // The name is specified in Android.mk / build.gradle / Makefile, depending on your build system. If you package your native library in a jar, you can also use com.dropbox.djinni.NativeLibLoader to help unpack and load your lib(s). See the Localhost README for details. When a native library is called, JNI calls a special function called JNI_OnLoad . If you use Djinni for all JNI interface code, include support_lib/jni/djinni_main.cpp ; if not, you'll need to add calls to your own JNI_OnLoad and JNI_OnUnload functions. See support-lib/jni/djinni_main.cpp for details.","title":"Our JNI approach"},{"location":"djinni-generator/usage/#objective-c-c-project","text":"","title":"Objective-C / C++ Project"},{"location":"djinni-generator/usage/#includes-build-target_1","text":"Generated files for Objective-C / C++ are as follows (assuming prefix is DB ): Type C++ header C++ source Objective-C files Objective-C++ files Enum/Flags my_enum.hpp DBMyEnum.h Record my_record[_base].hpp my_record[_base].cpp (+) DBMyRecord[Base].h DBMyRecord[Base]+Private.h DBMyRecord[Base].mm (++) DBMyRecord[Base]+Private.mm Interface my_interface.hpp my_interface.cpp (+) DBMyInterface.h DBMyInterface+Private.h DBMyInterface+Private.mm (+) Generated only for types that contain constants. (++) Generated only for types with derived operations and/or constants. These have .mm extensions to allow non-trivial constants. Add all generated files to your build target, as well as the contents of support-lib/objc . Note that +Private files can only be used with ObjC++ source (other headers are pure ObjC) and are not required by Objective-C users of your interface.","title":"Includes &amp; Build Target"},{"location":"djinni-intellij-plugin/getting-started/","text":"","title":"Getting Started"},{"location":"djinni-support-lib/install/","text":"Installing the Support-Lib \u00b6 conan \u00b6 TODO hunter \u00b6 TODO","title":"Installing the Support-Lib"},{"location":"djinni-support-lib/install/#installing-the-support-lib","text":"","title":"Installing the Support-Lib"},{"location":"djinni-support-lib/install/#conan","text":"TODO","title":"conan"},{"location":"djinni-support-lib/install/#hunter","text":"TODO","title":"hunter"}]}