{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Simple IDL \u00b6 The Djinni-IDL provides a simple, yet powerful way to design your interfaces. IDE Integration \u00b6 Plugins for the Djinni IDL are available for IntelliJ IDEA & VS Code Ready for the Future \u00b6 Djinni is also compatible with modern technologies. Call your C++ Code from Kotlin and Swift to have even more fun! Works in both directions \u00b6 Call in and out of C++ with ease:","title":"Home"},{"location":"#simple-idl","text":"The Djinni-IDL provides a simple, yet powerful way to design your interfaces.","title":"Simple IDL"},{"location":"#ide-integration","text":"Plugins for the Djinni IDL are available for IntelliJ IDEA & VS Code","title":"IDE Integration"},{"location":"#ready-for-the-future","text":"Djinni is also compatible with modern technologies. Call your C++ Code from Kotlin and Swift to have even more fun!","title":"Ready for the Future"},{"location":"#works-in-both-directions","text":"Call in and out of C++ with ease:","title":"Works in both directions"},{"location":"contributing/","text":"Contributing \u00b6 The cross-language-cpp project \u00b6 Cross-language-cpp is driven by individual people on a volunteer base. The idea for this project has been born at the Mobile C++ slack channel. Motivation \u00b6 Already before the sunset of the original djinni project it was not possible anymore to contribute to the project. A lot of ideas, bug fixes and new features have not been reported or submitted upstream. They are either available in various personal forks of djinni, or not available at all. Just to name an example, there are various javascript/nodejs implementation for djinni out there. They are all in personal forks, Often these project do not even know from each other. This is not optimal. Goals \u00b6 Continuation of the development of djinni and it's related tools. Avoid a single point of failure for the project. The goal is to have enough maintainers so the project will always have some administrator, and a read only state like the original project can be avoided. Be the place where new ideas and improvements to djinni and it's tools are collected and implemented. Becoming involved in the project \u00b6 As any open source project, we depend on the work of people that contribute to the project. Contributing to the project \u00b6 As mentioned, there have been various extension and additions to djinni been made. But most creators say the same: This is just a personal extension, a fast hack to make something work, not good enough for public release. These are all common reasons for not publishing code, and we think that they are not correct or should not be an impediment for not pushing changes back upstream. Release early, release often, if something is not good enough, it will either be not used or fixed. Open source evolution will care about. But the essential requirement is, make the changes available. There is nothing to lose, but everything to win! Becoming a maintainer \u00b6 As mentioned, one of the goals of the project is to establish a structure that ensures the availability of the project over time. For this to happen, maintainers are needed! For being a maintainer, we think the following points are important: Be available and responsive (as your time allows) : Respond in time to user request, or just be there when your time allows it. A reply I do not know now but I will come back is better than no reply for people that visit the project. Be reliable : If you admit to do something, please do not disappear without any notice. Be consistent (for some time) : It is common that people pop in full with ideas and energy, and this is great and such people are usual great contributors! But for a maintainer role it is also important to be consistent for more than just a few days or until 1 issue is realized or solved. No one expects commitment of a live time, but by taking a maintainer maybe for more than one week.","title":"Contributing"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#the-cross-language-cpp-project","text":"Cross-language-cpp is driven by individual people on a volunteer base. The idea for this project has been born at the Mobile C++ slack channel.","title":"The cross-language-cpp project"},{"location":"contributing/#motivation","text":"Already before the sunset of the original djinni project it was not possible anymore to contribute to the project. A lot of ideas, bug fixes and new features have not been reported or submitted upstream. They are either available in various personal forks of djinni, or not available at all. Just to name an example, there are various javascript/nodejs implementation for djinni out there. They are all in personal forks, Often these project do not even know from each other. This is not optimal.","title":"Motivation"},{"location":"contributing/#goals","text":"Continuation of the development of djinni and it's related tools. Avoid a single point of failure for the project. The goal is to have enough maintainers so the project will always have some administrator, and a read only state like the original project can be avoided. Be the place where new ideas and improvements to djinni and it's tools are collected and implemented.","title":"Goals"},{"location":"contributing/#becoming-involved-in-the-project","text":"As any open source project, we depend on the work of people that contribute to the project.","title":"Becoming involved in the project"},{"location":"contributing/#contributing-to-the-project","text":"As mentioned, there have been various extension and additions to djinni been made. But most creators say the same: This is just a personal extension, a fast hack to make something work, not good enough for public release. These are all common reasons for not publishing code, and we think that they are not correct or should not be an impediment for not pushing changes back upstream. Release early, release often, if something is not good enough, it will either be not used or fixed. Open source evolution will care about. But the essential requirement is, make the changes available. There is nothing to lose, but everything to win!","title":"Contributing to the project"},{"location":"contributing/#becoming-a-maintainer","text":"As mentioned, one of the goals of the project is to establish a structure that ensures the availability of the project over time. For this to happen, maintainers are needed! For being a maintainer, we think the following points are important: Be available and responsive (as your time allows) : Respond in time to user request, or just be there when your time allows it. A reply I do not know now but I will come back is better than no reply for people that visit the project. Be reliable : If you admit to do something, please do not disappear without any notice. Be consistent (for some time) : It is common that people pop in full with ideas and energy, and this is great and such people are usual great contributors! But for a maintainer role it is also important to be consistent for more than just a few days or until 1 issue is realized or solved. No one expects commitment of a live time, but by taking a maintainer maybe for more than one week.","title":"Becoming a maintainer"},{"location":"example/","text":"Example \u00b6 iOS \u00b6 TODO Android \u00b6 TODO","title":"Example"},{"location":"example/#example","text":"","title":"Example"},{"location":"example/#ios","text":"TODO","title":"iOS"},{"location":"example/#android","text":"TODO","title":"Android"},{"location":"icon_resources/","text":"Djinni Logo Resources \u00b6 The cross-language-cpp Djinni has a new, unique logo. If you want to report about or reference to our Project, please make sure to use the official Logo resources: Icon (800x800) Full Logo (1189 x 500) Affinity Designer Resource file","title":"Djinni Logo Resources"},{"location":"icon_resources/#djinni-logo-resources","text":"The cross-language-cpp Djinni has a new, unique logo. If you want to report about or reference to our Project, please make sure to use the official Logo resources: Icon (800x800) Full Logo (1189 x 500) Affinity Designer Resource file","title":"Djinni Logo Resources"},{"location":"overview/","text":"Overview \u00b6 What is djinni? \u00b6 Djinni is a tool for generating cross-language type declarations and interface bindings to connect C++ with either Java or Objective-C. Djinni can be used to interface cross-platform C++ library code with platform-specific Java and Objective-C on Android and iOS. Djinni was announced by Dropbox at CppCon 2014: Djinni \u2764\ufe0f Community! Dropbox ended maintenance of Djinni in March 2020. This fork wants to give Djinni a second life by transforming it to a community-driven project! We are currently in the early stage of migration to the all new cross-language-cpp organization. ( More Information... ) How the magic works \u00b6 To call from one programming language to another, usually a lot of gluecode is required. Djinni automatically generates this gluecode from an interface definition language (IDL) . All you need to do is implement the interfaces generated by djinni in one language and use it from the other language. Djinni takes care of the heavy lifting: Converting data-types, managing pointers and managing memory. Example: Call C++ Code from Java or Objective-C This Djinni Interface defines a class that is implemented in C++ and can be called from Java or Objective-C: HelloWorld = interface +c { static create(): HelloWorld; fromCpp(): string } Implemented in C++ #include \"djinni/generated/HelloWorld.hpp\" class HelloWorldImpl : public HelloWorld { public : static std :: shared_ptr < HelloWorld > create () { return std :: make_shared < HelloWorldImpl > (); } std :: string fromCpp () { return \"Hello From C++!\" ; } } Called from Java HelloWorld helloWorld = HelloWorld . create (); System . out . println ( helloWorld . fromCpp ()); // Hello from C++! or Objective-C HelloWorld * helloWorld = [ HelloWorld create ]; NSLog ([ helloWorld fromCpp ]); // Hello from C++! Example: Call Java/Objective-C Code from C++ This Djinni interface can be implemented in either Java or Objective-C, and can be called from C++: HelloWorld = interface +j +o { fromLanguage(): string; } Implemented in Java public class HelloWorldJava extends HelloWorld { @Override String fromLanguage () { return \"from Java\" ; } } or Objective-C @interface HelloWorldObjC : NSObject < HelloWorld > - ( NSString ) fromLanguage ; @end @implementation HelloWorldObjC - ( NSString ) fromLanguage { return \"from Objective-C\" ; } @end Called from C++ std :: cout << helloWorldInstance -> fromLanguage () << std :: endl ; Main Features \u00b6 Generates parallel C++, Java and Objective-C type definitions from a single interface description file. Supports the intersection of the three core languages' primitive types, and user-defined enums, flags, records, and interfaces. Generates interface code allowing bidirectional calls between C++ and Java (with JNI) or Objective-C (with Objective-C++). Can autogenerate comparator functions (equality, ordering) on data types. Components of Djinni \u00b6 Djinni consists of 2 important components: Generator : Command-line tool that takes an IDL file as input and generates the gluecode. Support lib : Library that is required for the gluecode to work.","title":"Overview"},{"location":"overview/#overview","text":"","title":"Overview"},{"location":"overview/#what-is-djinni","text":"Djinni is a tool for generating cross-language type declarations and interface bindings to connect C++ with either Java or Objective-C. Djinni can be used to interface cross-platform C++ library code with platform-specific Java and Objective-C on Android and iOS. Djinni was announced by Dropbox at CppCon 2014: Djinni \u2764\ufe0f Community! Dropbox ended maintenance of Djinni in March 2020. This fork wants to give Djinni a second life by transforming it to a community-driven project! We are currently in the early stage of migration to the all new cross-language-cpp organization. ( More Information... )","title":"What is djinni?"},{"location":"overview/#how-the-magic-works","text":"To call from one programming language to another, usually a lot of gluecode is required. Djinni automatically generates this gluecode from an interface definition language (IDL) . All you need to do is implement the interfaces generated by djinni in one language and use it from the other language. Djinni takes care of the heavy lifting: Converting data-types, managing pointers and managing memory. Example: Call C++ Code from Java or Objective-C This Djinni Interface defines a class that is implemented in C++ and can be called from Java or Objective-C: HelloWorld = interface +c { static create(): HelloWorld; fromCpp(): string } Implemented in C++ #include \"djinni/generated/HelloWorld.hpp\" class HelloWorldImpl : public HelloWorld { public : static std :: shared_ptr < HelloWorld > create () { return std :: make_shared < HelloWorldImpl > (); } std :: string fromCpp () { return \"Hello From C++!\" ; } } Called from Java HelloWorld helloWorld = HelloWorld . create (); System . out . println ( helloWorld . fromCpp ()); // Hello from C++! or Objective-C HelloWorld * helloWorld = [ HelloWorld create ]; NSLog ([ helloWorld fromCpp ]); // Hello from C++! Example: Call Java/Objective-C Code from C++ This Djinni interface can be implemented in either Java or Objective-C, and can be called from C++: HelloWorld = interface +j +o { fromLanguage(): string; } Implemented in Java public class HelloWorldJava extends HelloWorld { @Override String fromLanguage () { return \"from Java\" ; } } or Objective-C @interface HelloWorldObjC : NSObject < HelloWorld > - ( NSString ) fromLanguage ; @end @implementation HelloWorldObjC - ( NSString ) fromLanguage { return \"from Objective-C\" ; } @end Called from C++ std :: cout << helloWorldInstance -> fromLanguage () << std :: endl ;","title":"How the magic works"},{"location":"overview/#main-features","text":"Generates parallel C++, Java and Objective-C type definitions from a single interface description file. Supports the intersection of the three core languages' primitive types, and user-defined enums, flags, records, and interfaces. Generates interface code allowing bidirectional calls between C++ and Java (with JNI) or Objective-C (with Objective-C++). Can autogenerate comparator functions (equality, ordering) on data types.","title":"Main Features"},{"location":"overview/#components-of-djinni","text":"Djinni consists of 2 important components: Generator : Command-line tool that takes an IDL file as input and generates the gluecode. Support lib : Library that is required for the gluecode to work.","title":"Components of Djinni"},{"location":"setup/","text":"Setup \u00b6 The following steps are required to get you started: 1. Installation of Generator \u00b6 Get the latest version of the generator from github . Go here for more detailed install instructions. 2. Add the support-lib to your project \u00b6 The support-lib will be available for multiple package managers soon. Stay tuned! Go here for more detailed install instructions. 3. Install IDE Plugin \u00b6 For syntax checking and highlighting of the Djinni-IDL install the plugin for your IDE: VS Code : ( download ) IntelliJ IDEA : ( download , documentation )","title":"Setup"},{"location":"setup/#setup","text":"The following steps are required to get you started:","title":"Setup"},{"location":"setup/#1-installation-of-generator","text":"Get the latest version of the generator from github . Go here for more detailed install instructions.","title":"1. Installation of Generator"},{"location":"setup/#2-add-the-support-lib-to-your-project","text":"The support-lib will be available for multiple package managers soon. Stay tuned! Go here for more detailed install instructions.","title":"2. Add the support-lib to your project"},{"location":"setup/#3-install-ide-plugin","text":"For syntax checking and highlighting of the Djinni-IDL install the plugin for your IDE: VS Code : ( download ) IntelliJ IDEA : ( download , documentation )","title":"3. Install IDE Plugin"},{"location":"vscode-plugin/","text":"VS Code Plugin \u00b6 The VS Code Plugin is not (yet) maintained by cross-language-cpp . For more details head over to the maintainers repository .","title":"VS Code Plugin"},{"location":"vscode-plugin/#vs-code-plugin","text":"The VS Code Plugin is not (yet) maintained by cross-language-cpp . For more details head over to the maintainers repository .","title":"VS Code Plugin"},{"location":"djinni-generator/cli-usage/","text":"Using the Generator \u00b6 When the Djinni file(s) are ready, from the command line you can run: djinni \\ --java-out JAVA_OUTPUT_FOLDER \\ --java-package com.example.jnigenpackage \\ --java-cpp-exception DbxException \\ # Choose between a customized C++ exception in Java and java.lang.RuntimeException (the default). --ident-java-field mFooBar \\ # Optional, this adds an \"m\" in front of Java field names \\ --cpp-out CPP_OUTPUT_FOLDER \\ \\ --jni-out JNI_OUTPUT_FOLDER \\ --ident-jni-class NativeFooBar \\ # This adds a \"Native\" prefix to JNI class --ident-jni-file NativeFooBar \\ # This adds a prefix to the JNI filenames otherwise the cpp and jni filenames are the same. \\ --objc-out OBJC_OUTPUT_FOLDER \\ --objc-type-prefix DB \\ # Apple suggests Objective-C classes have a prefix for each defined type. \\ --objcpp-out OBJC_OUTPUT_FOLDER \\ \\ --idl MY_PROJECT.djinni Note If a language's output folder is not specified, that language will not be generated. All Arguments \u00b6 General \u00b6 Argument Description --help Print help --version Print version --idl <in-file> The IDL file with the type definitions, typically with extension .djinni . --idl-include-path <path> ... An include path to search for Djinni @import directives. Can specify multiple paths. Java \u00b6 Argument Description --java-out <out-folder> The output for the Java files (Generator disabled if unspecified). --java-package ... The package name to use for generated Java classes. --java-class-access-modifier <public/package> The access modifier to use for generated Java classes (default: public ). --java-cpp-exception <exception-class> The type for translated C++ exceptions in Java (default: java.lang.RuntimeException that is not checked) --java-annotation <annotation-class> Java annotation ( @Foo ) to place on all generated Java classes --java-generate-interfaces <true/false> Whether Java interfaces should be used instead of abstract classes where possible (default: false). --java-nullable-annotation <nullable-annotation-class> Java annotation ( @Nullable ) to place on all fields and return values that are optional --java-nonnull-annotation <nonnull-annotation-class> Java annotation ( @Nonnull ) to place on all fields and return values that are not optional --java-implement-android-os-parcelable <true/false> all generated java classes will implement the interface android.os.Parcelable --java-use-final-for-record <use-final-for-record> Whether generated Java classes for records should be marked final (default: true ). C++ \u00b6 Argument Description --cpp-out <out-folder> The output folder for C++ files (Generator disabled if unspecified). --cpp-header-out <out-folder> The output folder for C++ header files (default: the same as --cpp-out ). --cpp-include-prefix <prefix> The prefix for #includes of header files from C++ files. --cpp-namespace ... The namespace name to use for generated C++ classes. --cpp-ext <ext> The filename extension for C++ files (default: cpp ). --hpp-ext <ext> The filename extension for C++ header files (default: hpp ). --cpp-optional-template <template> The template to use for optional values (default: std::optional ) --cpp-optional-header <header> The header to use for optional values (default: <optional> ) --cpp-enum-hash-workaround <true/false> Work around LWG-2148 by generating std::hash specializations for C++ enums (default: true ) --cpp-nn-header <header> The header to use for non-nullable pointers --cpp-nn-type <header> The type to use for non-nullable pointers (as a substitute for std::shared_ptr ) --cpp-nn-check-expression <header> The expression to use for building non-nullable pointers --cpp-use-wide-strings <true/false> Use wide strings in C++ code (default: false ) JNI \u00b6 Argument Description --jni-out <out-folder> The folder for the JNI C++ output files (Generator disabled if unspecified). --jni-header-out <out-folder> The folder for the JNI C++ header files (default: the same as --jni-out ). --jni-include-prefix <prefix> The prefix for #includes of JNI header files from JNI C++ files. --jni-include-cpp-prefix <prefix> The prefix for #includes of the main header files from JNI C++ files. --jni-namespace ... The namespace name to use for generated JNI C++ classes. --jni-base-lib-include-prefix ... The JNI base support library's include path (default: djinni/jni/). Objective-C \u00b6 Argument Description --objc-out <out-folder> The output folder for Objective-C files (Generator disabled if unspecified). --objc-header-out <out-folder> The output folder for Objective-C header files (default: the same as --objc-out). --objc-h-ext <ext> The filename extension for Objective-C[++] header files (default: h ) --objc-type-prefix <pre> The prefix for Objective-C data types (usually two or three letters) --objc-include-prefix <prefix> The prefix for #import of header files from Objective-C files. --objc-swift-bridging-header <name> The name of Objective-C Bridging Header used in XCode's Swift projects. --objc-closed-enums <true/false> All generated Objective-C enums will be NS_CLOSED_ENUM (default: false ). Objective-C++ \u00b6 Argument Description --objcpp-out <out-folder> The output folder for private Objective-C++ files (Generator disabled if unspecified). --objcpp-ext <ext> The filename extension for Objective-C++ files (default: mm ) --objcpp-include-prefix <prefix> The prefix for #import of Objective-C++ header files from Objective-C++ files. --objcpp-include-cpp-prefix <prefix> The prefix for #include of the main C++ header files from Objective-C++ files. --objcpp-include-objc-prefix <prefix> The prefix for #import of the Objective-C header files from Objective-C++ files (default: the same as --objcpp-include-prefix ) --cpp-extended-record-include-prefix <prefix> The prefix path for #include of the extended record C++ header ( .hpp ) files --objc-extended-record-include-prefix <prefix> The prefix path for #import of the extended record Objective-C header ( .h ) files --objcpp-namespace <prefix> The namespace name to use for generated Objective-C++ classes. --objc-base-lib-include-prefix ... The Objective-C base support library's include path (default: djinni/objc/). Yaml Generation \u00b6 Argument Description --yaml-out <out-folder> The output folder for YAML files (Generator disabled if unspecified). --yaml-out-file <out-file> If specified all types are merged into a single YAML file instead of generating one file per type (relative to --yaml-out ). --yaml-prefix <pre> The prefix to add to type names stored in YAML files (default: \"\"). Other \u00b6 Argument Description --list-in-files <list-in-files> Optional file in which to write the list of input files parsed. --list-out-files <list-out-files> Optional file in which to write the list of output files produced. --skip-generation <true/false> Way of specifying if file generation should be skipped (default: false ) Identifier Style \u00b6 Identifier styles (ex: FooBar , fooBar , foo_bar , FOO_BAR , m_fooBar ) Argument --ident-java-enum ... --ident-java-field ... --ident-java-type ... --ident-cpp-enum ... --ident-cpp-field ... --ident-cpp-method ... --ident-cpp-type ... --ident-cpp-enum-type ... --ident-cpp-type-param ... --ident-cpp-local ... --ident-cpp-file ... --ident-jni-class ... --ident-jni-file ... --ident-objc-enum ... --ident-objc-field ... --ident-objc-method ... --ident-objc-type ... --ident-objc-type-param ... --ident-objc-local ... --ident-objc-file ... The Identifier Style is a text conversion hint on how to generate names from the djinni idl file. Example: The djinni idl for an enum SomeEnum = enum { Value; } transforms per default to the following Java code public enum SomeEnum { VALUE, ; } As you see, VALUE is now in upper case letters. If you use --ident-java-enum foo_bar then Value will not be transformed into upper case and the following Java code will be generated. public enum SomeEnum { Value, ; } This way you can adopt code generation to some extend to your existing coding style. The best way to find out how that works is playing around with different values for different identifier options. If you wish not text transformation to happen, use the foo_bar style. Note Some identifiers do have text transformation enabled by default. Nevertheless make sure to explicitly set text transformation styles if you need them! All text transformation may be disabled by default in a future release of the generator.","title":"Using the Generator"},{"location":"djinni-generator/cli-usage/#using-the-generator","text":"When the Djinni file(s) are ready, from the command line you can run: djinni \\ --java-out JAVA_OUTPUT_FOLDER \\ --java-package com.example.jnigenpackage \\ --java-cpp-exception DbxException \\ # Choose between a customized C++ exception in Java and java.lang.RuntimeException (the default). --ident-java-field mFooBar \\ # Optional, this adds an \"m\" in front of Java field names \\ --cpp-out CPP_OUTPUT_FOLDER \\ \\ --jni-out JNI_OUTPUT_FOLDER \\ --ident-jni-class NativeFooBar \\ # This adds a \"Native\" prefix to JNI class --ident-jni-file NativeFooBar \\ # This adds a prefix to the JNI filenames otherwise the cpp and jni filenames are the same. \\ --objc-out OBJC_OUTPUT_FOLDER \\ --objc-type-prefix DB \\ # Apple suggests Objective-C classes have a prefix for each defined type. \\ --objcpp-out OBJC_OUTPUT_FOLDER \\ \\ --idl MY_PROJECT.djinni Note If a language's output folder is not specified, that language will not be generated.","title":"Using the Generator"},{"location":"djinni-generator/cli-usage/#all-arguments","text":"","title":"All Arguments"},{"location":"djinni-generator/cli-usage/#general","text":"Argument Description --help Print help --version Print version --idl <in-file> The IDL file with the type definitions, typically with extension .djinni . --idl-include-path <path> ... An include path to search for Djinni @import directives. Can specify multiple paths.","title":"General"},{"location":"djinni-generator/cli-usage/#java","text":"Argument Description --java-out <out-folder> The output for the Java files (Generator disabled if unspecified). --java-package ... The package name to use for generated Java classes. --java-class-access-modifier <public/package> The access modifier to use for generated Java classes (default: public ). --java-cpp-exception <exception-class> The type for translated C++ exceptions in Java (default: java.lang.RuntimeException that is not checked) --java-annotation <annotation-class> Java annotation ( @Foo ) to place on all generated Java classes --java-generate-interfaces <true/false> Whether Java interfaces should be used instead of abstract classes where possible (default: false). --java-nullable-annotation <nullable-annotation-class> Java annotation ( @Nullable ) to place on all fields and return values that are optional --java-nonnull-annotation <nonnull-annotation-class> Java annotation ( @Nonnull ) to place on all fields and return values that are not optional --java-implement-android-os-parcelable <true/false> all generated java classes will implement the interface android.os.Parcelable --java-use-final-for-record <use-final-for-record> Whether generated Java classes for records should be marked final (default: true ).","title":"Java"},{"location":"djinni-generator/cli-usage/#c","text":"Argument Description --cpp-out <out-folder> The output folder for C++ files (Generator disabled if unspecified). --cpp-header-out <out-folder> The output folder for C++ header files (default: the same as --cpp-out ). --cpp-include-prefix <prefix> The prefix for #includes of header files from C++ files. --cpp-namespace ... The namespace name to use for generated C++ classes. --cpp-ext <ext> The filename extension for C++ files (default: cpp ). --hpp-ext <ext> The filename extension for C++ header files (default: hpp ). --cpp-optional-template <template> The template to use for optional values (default: std::optional ) --cpp-optional-header <header> The header to use for optional values (default: <optional> ) --cpp-enum-hash-workaround <true/false> Work around LWG-2148 by generating std::hash specializations for C++ enums (default: true ) --cpp-nn-header <header> The header to use for non-nullable pointers --cpp-nn-type <header> The type to use for non-nullable pointers (as a substitute for std::shared_ptr ) --cpp-nn-check-expression <header> The expression to use for building non-nullable pointers --cpp-use-wide-strings <true/false> Use wide strings in C++ code (default: false )","title":"C++"},{"location":"djinni-generator/cli-usage/#jni","text":"Argument Description --jni-out <out-folder> The folder for the JNI C++ output files (Generator disabled if unspecified). --jni-header-out <out-folder> The folder for the JNI C++ header files (default: the same as --jni-out ). --jni-include-prefix <prefix> The prefix for #includes of JNI header files from JNI C++ files. --jni-include-cpp-prefix <prefix> The prefix for #includes of the main header files from JNI C++ files. --jni-namespace ... The namespace name to use for generated JNI C++ classes. --jni-base-lib-include-prefix ... The JNI base support library's include path (default: djinni/jni/).","title":"JNI"},{"location":"djinni-generator/cli-usage/#objective-c","text":"Argument Description --objc-out <out-folder> The output folder for Objective-C files (Generator disabled if unspecified). --objc-header-out <out-folder> The output folder for Objective-C header files (default: the same as --objc-out). --objc-h-ext <ext> The filename extension for Objective-C[++] header files (default: h ) --objc-type-prefix <pre> The prefix for Objective-C data types (usually two or three letters) --objc-include-prefix <prefix> The prefix for #import of header files from Objective-C files. --objc-swift-bridging-header <name> The name of Objective-C Bridging Header used in XCode's Swift projects. --objc-closed-enums <true/false> All generated Objective-C enums will be NS_CLOSED_ENUM (default: false ).","title":"Objective-C"},{"location":"djinni-generator/cli-usage/#objective-c_1","text":"Argument Description --objcpp-out <out-folder> The output folder for private Objective-C++ files (Generator disabled if unspecified). --objcpp-ext <ext> The filename extension for Objective-C++ files (default: mm ) --objcpp-include-prefix <prefix> The prefix for #import of Objective-C++ header files from Objective-C++ files. --objcpp-include-cpp-prefix <prefix> The prefix for #include of the main C++ header files from Objective-C++ files. --objcpp-include-objc-prefix <prefix> The prefix for #import of the Objective-C header files from Objective-C++ files (default: the same as --objcpp-include-prefix ) --cpp-extended-record-include-prefix <prefix> The prefix path for #include of the extended record C++ header ( .hpp ) files --objc-extended-record-include-prefix <prefix> The prefix path for #import of the extended record Objective-C header ( .h ) files --objcpp-namespace <prefix> The namespace name to use for generated Objective-C++ classes. --objc-base-lib-include-prefix ... The Objective-C base support library's include path (default: djinni/objc/).","title":"Objective-C++"},{"location":"djinni-generator/cli-usage/#yaml-generation","text":"Argument Description --yaml-out <out-folder> The output folder for YAML files (Generator disabled if unspecified). --yaml-out-file <out-file> If specified all types are merged into a single YAML file instead of generating one file per type (relative to --yaml-out ). --yaml-prefix <pre> The prefix to add to type names stored in YAML files (default: \"\").","title":"Yaml Generation"},{"location":"djinni-generator/cli-usage/#other","text":"Argument Description --list-in-files <list-in-files> Optional file in which to write the list of input files parsed. --list-out-files <list-out-files> Optional file in which to write the list of output files produced. --skip-generation <true/false> Way of specifying if file generation should be skipped (default: false )","title":"Other"},{"location":"djinni-generator/cli-usage/#identifier-style","text":"Identifier styles (ex: FooBar , fooBar , foo_bar , FOO_BAR , m_fooBar ) Argument --ident-java-enum ... --ident-java-field ... --ident-java-type ... --ident-cpp-enum ... --ident-cpp-field ... --ident-cpp-method ... --ident-cpp-type ... --ident-cpp-enum-type ... --ident-cpp-type-param ... --ident-cpp-local ... --ident-cpp-file ... --ident-jni-class ... --ident-jni-file ... --ident-objc-enum ... --ident-objc-field ... --ident-objc-method ... --ident-objc-type ... --ident-objc-type-param ... --ident-objc-local ... --ident-objc-file ... The Identifier Style is a text conversion hint on how to generate names from the djinni idl file. Example: The djinni idl for an enum SomeEnum = enum { Value; } transforms per default to the following Java code public enum SomeEnum { VALUE, ; } As you see, VALUE is now in upper case letters. If you use --ident-java-enum foo_bar then Value will not be transformed into upper case and the following Java code will be generated. public enum SomeEnum { Value, ; } This way you can adopt code generation to some extend to your existing coding style. The best way to find out how that works is playing around with different values for different identifier options. If you wish not text transformation to happen, use the foo_bar style. Note Some identifiers do have text transformation enabled by default. Nevertheless make sure to explicitly set text transformation styles if you need them! All text transformation may be disabled by default in a future release of the generator.","title":"Identifier Style"},{"location":"djinni-generator/developer-guide/","text":"Developer Guide \u00b6 Info This chapter is only interesting if you intend to make changes to the code of djinni generator Building from source \u00b6 Build dependencies \u00b6 Java JDK 8 or 11 sbt Building \u00b6 To build once: sbt compile To automatically re-build on every change, open the sbt shell & prefix compile with ~ $ sbt sbt:djinni> ~compile Running \u00b6 sbt \"run --idl input.djinni --cpp-out out/cpp --java-out out/java/src --jni-out out/java/jni --objc-out out/objc\" sbt \"run --help\" # show all options It is important to put run and all arguments in \" , to be able to pass arguments to the executed jar Running Tests \u00b6 sbt it:test Packaging \u00b6 Create a binary like the one that is published on github releases: sbt assembly This will generate a standalone, self-executing jar in target/bin . You can run the jar like this (no need for java -jar ): ./djinni --help On Windows the file must be renamed to djinni.bat to make it executable. Attention The resulting binary still requires Java to able to run! Details on how the self-executing jar works . Project Structure \u00b6 TODO Release process \u00b6 To release a new version of the generator, the following steps must be followed: Create a new release-tag. Set a meaningful version number and describe what has changed in the new version. Wait. Github will automatically build the project and upload the resulting binaries to the release.","title":"Developer Guide"},{"location":"djinni-generator/developer-guide/#developer-guide","text":"Info This chapter is only interesting if you intend to make changes to the code of djinni generator","title":"Developer Guide"},{"location":"djinni-generator/developer-guide/#building-from-source","text":"","title":"Building from source"},{"location":"djinni-generator/developer-guide/#build-dependencies","text":"Java JDK 8 or 11 sbt","title":"Build dependencies"},{"location":"djinni-generator/developer-guide/#building","text":"To build once: sbt compile To automatically re-build on every change, open the sbt shell & prefix compile with ~ $ sbt sbt:djinni> ~compile","title":"Building"},{"location":"djinni-generator/developer-guide/#running","text":"sbt \"run --idl input.djinni --cpp-out out/cpp --java-out out/java/src --jni-out out/java/jni --objc-out out/objc\" sbt \"run --help\" # show all options It is important to put run and all arguments in \" , to be able to pass arguments to the executed jar","title":"Running"},{"location":"djinni-generator/developer-guide/#running-tests","text":"sbt it:test","title":"Running Tests"},{"location":"djinni-generator/developer-guide/#packaging","text":"Create a binary like the one that is published on github releases: sbt assembly This will generate a standalone, self-executing jar in target/bin . You can run the jar like this (no need for java -jar ): ./djinni --help On Windows the file must be renamed to djinni.bat to make it executable. Attention The resulting binary still requires Java to able to run! Details on how the self-executing jar works .","title":"Packaging"},{"location":"djinni-generator/developer-guide/#project-structure","text":"TODO","title":"Project Structure"},{"location":"djinni-generator/developer-guide/#release-process","text":"To release a new version of the generator, the following steps must be followed: Create a new release-tag. Set a meaningful version number and describe what has changed in the new version. Wait. Github will automatically build the project and upload the resulting binaries to the release.","title":"Release process"},{"location":"djinni-generator/generated-code-usage/","text":"Use Generated Code \u00b6 Java / JNI / C++ Project \u00b6 Includes & Build target \u00b6 The following headers / code will be generated for each defined type: Type C++ header C++ source Java JNI header JNI source Enum/Flags my_enum.hpp MyEnum.java NativeMyEnum.hpp NativeMyEnum.cpp Record my_record[_base].hpp my_record[_base].cpp (+) MyRecord[Base].java NativeMyRecord.hpp NativeMyRecord.cpp Interface my_interface.hpp my_interface.cpp (+) MyInterface.java NativeMyInterface.hpp NativeMyInterface.cpp (+) Generated only for types that contain constants. Add all generated source files to your build target, as well as the contents of support-lib/java . Our JNI approach \u00b6 JNI stands for Java Native Interface , an extension of the Java language to allow interop with native (C/C++) code or libraries. For each type, built-in ( list , string , etc.) or user-defined, Djinni produces a translator class with a toJava and fromJava function to translate back and forth. Application code is responsible for the initial load of the JNI library. Add a static block somewhere in your code: System.loadLibrary(\"YourLibraryName\"); // The name is specified in Android.mk / build.gradle / Makefile, depending on your build system. If you package your native library in a jar, you can also use the NativeLibLoader to help unpack and load your lib(s). When a native library is called, JNI calls a special function called JNI_OnLoad . If you use Djinni for all JNI interface code, include support_lib/jni/djinni_main.cpp ; if not, you'll need to add calls to your own JNI_OnLoad and JNI_OnUnload functions. See support-lib/jni/djinni_main.cpp for details. Objective-C / C++ Project \u00b6 Includes & Build Target \u00b6 Generated files for Objective-C / C++ are as follows (assuming prefix is DB ): Type C++ header C++ source Objective-C files Objective-C++ files Enum/Flags my_enum.hpp DBMyEnum.h Record my_record[_base].hpp my_record[_base].cpp DBMyRecord[Base].h DBMyRecord[Base]+Private.h DBMyRecord[Base].mm DBMyRecord[Base]+Private.mm Interface my_interface.hpp my_interface.cpp DBMyInterface.h DBMyInterface+Private.h DBMyInterface+Private.mm Generated only for types that contain constants. Generated only for types with derived operations and/or constants. These have .mm extensions to allow non-trivial constants. Add all generated files to your build target, as well as the contents of support-lib/objc . Note that +Private files can only be used with ObjC++ source (other headers are pure ObjC) and are not required by Objective-C users of your interface.","title":"Use Generated Code"},{"location":"djinni-generator/generated-code-usage/#use-generated-code","text":"","title":"Use Generated Code"},{"location":"djinni-generator/generated-code-usage/#java-jni-c-project","text":"","title":"Java / JNI / C++ Project"},{"location":"djinni-generator/generated-code-usage/#includes-build-target","text":"The following headers / code will be generated for each defined type: Type C++ header C++ source Java JNI header JNI source Enum/Flags my_enum.hpp MyEnum.java NativeMyEnum.hpp NativeMyEnum.cpp Record my_record[_base].hpp my_record[_base].cpp (+) MyRecord[Base].java NativeMyRecord.hpp NativeMyRecord.cpp Interface my_interface.hpp my_interface.cpp (+) MyInterface.java NativeMyInterface.hpp NativeMyInterface.cpp (+) Generated only for types that contain constants. Add all generated source files to your build target, as well as the contents of support-lib/java .","title":"Includes &amp; Build target"},{"location":"djinni-generator/generated-code-usage/#our-jni-approach","text":"JNI stands for Java Native Interface , an extension of the Java language to allow interop with native (C/C++) code or libraries. For each type, built-in ( list , string , etc.) or user-defined, Djinni produces a translator class with a toJava and fromJava function to translate back and forth. Application code is responsible for the initial load of the JNI library. Add a static block somewhere in your code: System.loadLibrary(\"YourLibraryName\"); // The name is specified in Android.mk / build.gradle / Makefile, depending on your build system. If you package your native library in a jar, you can also use the NativeLibLoader to help unpack and load your lib(s). When a native library is called, JNI calls a special function called JNI_OnLoad . If you use Djinni for all JNI interface code, include support_lib/jni/djinni_main.cpp ; if not, you'll need to add calls to your own JNI_OnLoad and JNI_OnUnload functions. See support-lib/jni/djinni_main.cpp for details.","title":"Our JNI approach"},{"location":"djinni-generator/generated-code-usage/#objective-c-c-project","text":"","title":"Objective-C / C++ Project"},{"location":"djinni-generator/generated-code-usage/#includes-build-target_1","text":"Generated files for Objective-C / C++ are as follows (assuming prefix is DB ): Type C++ header C++ source Objective-C files Objective-C++ files Enum/Flags my_enum.hpp DBMyEnum.h Record my_record[_base].hpp my_record[_base].cpp DBMyRecord[Base].h DBMyRecord[Base]+Private.h DBMyRecord[Base].mm DBMyRecord[Base]+Private.mm Interface my_interface.hpp my_interface.cpp DBMyInterface.h DBMyInterface+Private.h DBMyInterface+Private.mm Generated only for types that contain constants. Generated only for types with derived operations and/or constants. These have .mm extensions to allow non-trivial constants. Add all generated files to your build target, as well as the contents of support-lib/objc . Note that +Private files can only be used with ObjC++ source (other headers are pure ObjC) and are not required by Objective-C users of your interface.","title":"Includes &amp; Build Target"},{"location":"djinni-generator/idl/","text":"Interface Definition Language (IDL) \u00b6 Djinni's input is an interface description file. Here's an example: # Multi-line comments can be added here. This comment will be propagated # to each generated definition. my_enum = enum { option1; option2; option3; } my_flags = flags { flag1; flag2; flag3; no_flags = none; all_flags = all; } my_record = record { id: i32; info: string; store: set<string>; hash: map<string, i32>; values: list<another_record>; # Comments can also be put here # Constants can be included const string_const: string = \"Constants can be put here\"; const min_value: another_record = { key1 = 0, key2 = \"\" }; } another_record = record { key1: i32; key2: string; } deriving (eq, ord) # This interface will be implemented in C++ and can be called from any language. my_cpp_interface = interface +c { method_returning_nothing(value: i32); method_returning_some_type(key: string): another_record; static get_version(): i32; # Interfaces can also have constants const version: i32 = 1; } # This interface will be implemented in Java and ObjC and can be called from C++. my_client_interface = interface +j +o { log_string(str: string): bool; } Djinni files can also include each other. Adding the line: @import \"relative/path/to/filename.djinni\" at the beginning of a file will simply include another file. Child file paths are relative to the location of the file that contains the @import. Two different djinni files cannot define the same type. @import behaves like #include with #pragma once in C++, or like ObjC's #import : if a file is included multiple times through different paths, then it will only be processed once. Data Types \u00b6 The available data types for a record, argument, or return value are: Boolean ( bool ) Primitives ( i8 , i16 , i32 , i64 , f32 , f64 ). Strings ( string ) Binary ( binary ). This is implemented as std::vector<uint8_t> in C++, byte[] in Java, and NSData in Objective-C. Date ( date ). This is chrono::system_clock::time_point in C++, Date in Java, and NSDate in Objective-C. List ( list<type> ). This is vector<T> in C++, ArrayList in Java, and NSArray in Objective-C. Primitives in a list will be boxed in Java and Objective-C. Set ( set<type> ). This is unordered_set<T> in C++, HashSet in Java, and NSSet in Objective-C. Primitives in a set will be boxed in Java and Objective-C. Map ( map<typeA, typeB> ). This is unordered_map<K, V> in C++, HashMap in Java, and NSDictionary in Objective-C. Primitives in a map will be boxed in Java and Objective-C. Enumerations / Flags Optionals ( optional<typeA> ). This is std::experimental::optional<T> in C++11, object / boxed primitive reference in Java (which can be null ), and object / NSNumber strong reference in Objective-C (which can be nil ). Other record types. This is generated with a by-value semantic, i.e. the copy method will deep-copy the contents. Types \u00b6 An IDL file can contain 4 kinds of declarations: enums, flags, records, and interfaces. Enums become C++ enum classes, Java enums, or ObjC NS_ENUM s. Flags become C++ enum classes with convenient bit-oriented operators, Java enums with EnumSet , or ObjC NS_OPTIONS . Records are pure-data value objects. Interfaces are objects with defined methods to call (in C++, passed by shared_ptr ). Djinni produces code allowing an interface implemented in C++ to be transparently used from ObjC or Java, and vice versa. Enums \u00b6 my_enum = enum { option1; option2; option3; } Enums are translated to C++ enum class es with underlying type int , ObjC NS_ENUM s with underlying type NSInteger , and Java enums. Flags \u00b6 my_flags = flags { flag1; flag2; flag3; no_flags = none; all_flags = all; } Flags are translated to C++ enum class es with underlying type unsigned and a generated set of overloaded bitwise operators for convenience, ObjC NS_OPTIONS with underlying type NSUInteger , and Java EnumSet<> . Contrary to the above enums, the enumerants of flags represent single bits instead of integral values. In the above example the elements marked with none and all are given special meaning. In C++ and ObjC the no_flags option is generated with a value that has no bits set (i.e. 0 ), and all_flags is generated as a bitwise-or combination of all other values. In Java these special options are not generated as one can just use EnumSet.noneOf() and EnumSet.allOf() . Records \u00b6 my_record = record { id: i32; info: string; store: set<string>; hash: map<string, i32>; values: list<another_record>; # Comments can also be put here # Constants can be included const string_const: string = \"Constants can be put here\"; const min_value: another_record = { key1 = 0, key2 = \"\" }; } Records are data objects. In C++, records contain all their elements by value, including other records (so a record cannot contain itself). Extensions \u00b6 To support extra fields and/or methods, a record can be \"extended\" in any language. To extend a record in a language, you can add a +c (C++), +j (Java), or +o (ObjC) flag after the record tag. The generated type will have a Base suffix, and you should create a derived type without the suffix that extends the record type. The derived type must be constructible in the same way as the Base type. Interfaces will always use the derived type. Derived methods \u00b6 another_record = record { key1: i32; key2: string; } deriving (eq, ord) For record types, Haskell-style \"deriving\" declarations are supported to generate some common methods. Djinni is capable of generating equality and order comparators, implemented as operator overloading in C++ and standard comparison functions in Java / Objective-C. Note All fields in the record are compared in the order they appear in the record declaration. If you need to add a field later, make sure the order is correct. Ordering comparison is not supported for collection types, optionals, and booleans. To compare records containing other records, the inner record must derive at least the same types of comparators as the outer record. Interfaces \u00b6 # This interface will be implemented in C++ and can be called from any language. my_cpp_interface = interface +c { method_returning_nothing(value: i32); method_returning_some_type(key: string): another_record; static get_version(): i32; # Interfaces can also have constants const version: i32 = 1; } # This interface will be implemented in Java and ObjC and can be called from C++. my_client_interface = interface +j +o { log_string(str: string): bool; } Interfaces are objects with defined methods to call (in C++, passed by shared_ptr ). Djinni produces code allowing an interface implemented in C++ to be transparently used from ObjC or Java, and vice versa. Special Methods for C++ Only \u00b6 +c interfaces (implementable only in C++) can have methods flagged with the special keywords const and static which have special effects in C++: special_methods = interface +c { const accessor_method(); static factory_method(); } const methods will be declared as const in C++, though this cannot be enforced on callers in other languages, which lack this feature. static methods will become a static method of the C++ class, which can be called from other languages without an object. This is often useful for factory methods to act as a cross-language constructor. Exception Handling \u00b6 When an interface implemented in C++ throws a std::exception , it will be translated to a java.lang.RuntimeException in Java or an NSException in Objective-C. The what() message will be translated as well. Constants \u00b6 Constants can be defined within interfaces and records. In Java and C++ they are part of the generated class; and in Objective-C, constant names are globals with the name of the interface/record prefixed. Example: record_with_const = record +c +j +o { const const_value: i32 = 8; } will be RecordWithConst::CONST_VALUE in C++, RecordWithConst.CONST_VALUE in Java, and RecordWithConstConstValue in Objective-C. Comments \u00b6 # This is a comment If comments are are placed on top or inside a type definition , they will be converted to Javadoc / Doxygen compatible comments in the generated Java/C++/Objective-C interfaces.","title":"Interface Definition Language (IDL)"},{"location":"djinni-generator/idl/#interface-definition-language-idl","text":"Djinni's input is an interface description file. Here's an example: # Multi-line comments can be added here. This comment will be propagated # to each generated definition. my_enum = enum { option1; option2; option3; } my_flags = flags { flag1; flag2; flag3; no_flags = none; all_flags = all; } my_record = record { id: i32; info: string; store: set<string>; hash: map<string, i32>; values: list<another_record>; # Comments can also be put here # Constants can be included const string_const: string = \"Constants can be put here\"; const min_value: another_record = { key1 = 0, key2 = \"\" }; } another_record = record { key1: i32; key2: string; } deriving (eq, ord) # This interface will be implemented in C++ and can be called from any language. my_cpp_interface = interface +c { method_returning_nothing(value: i32); method_returning_some_type(key: string): another_record; static get_version(): i32; # Interfaces can also have constants const version: i32 = 1; } # This interface will be implemented in Java and ObjC and can be called from C++. my_client_interface = interface +j +o { log_string(str: string): bool; } Djinni files can also include each other. Adding the line: @import \"relative/path/to/filename.djinni\" at the beginning of a file will simply include another file. Child file paths are relative to the location of the file that contains the @import. Two different djinni files cannot define the same type. @import behaves like #include with #pragma once in C++, or like ObjC's #import : if a file is included multiple times through different paths, then it will only be processed once.","title":"Interface Definition Language (IDL)"},{"location":"djinni-generator/idl/#data-types","text":"The available data types for a record, argument, or return value are: Boolean ( bool ) Primitives ( i8 , i16 , i32 , i64 , f32 , f64 ). Strings ( string ) Binary ( binary ). This is implemented as std::vector<uint8_t> in C++, byte[] in Java, and NSData in Objective-C. Date ( date ). This is chrono::system_clock::time_point in C++, Date in Java, and NSDate in Objective-C. List ( list<type> ). This is vector<T> in C++, ArrayList in Java, and NSArray in Objective-C. Primitives in a list will be boxed in Java and Objective-C. Set ( set<type> ). This is unordered_set<T> in C++, HashSet in Java, and NSSet in Objective-C. Primitives in a set will be boxed in Java and Objective-C. Map ( map<typeA, typeB> ). This is unordered_map<K, V> in C++, HashMap in Java, and NSDictionary in Objective-C. Primitives in a map will be boxed in Java and Objective-C. Enumerations / Flags Optionals ( optional<typeA> ). This is std::experimental::optional<T> in C++11, object / boxed primitive reference in Java (which can be null ), and object / NSNumber strong reference in Objective-C (which can be nil ). Other record types. This is generated with a by-value semantic, i.e. the copy method will deep-copy the contents.","title":"Data Types"},{"location":"djinni-generator/idl/#types","text":"An IDL file can contain 4 kinds of declarations: enums, flags, records, and interfaces. Enums become C++ enum classes, Java enums, or ObjC NS_ENUM s. Flags become C++ enum classes with convenient bit-oriented operators, Java enums with EnumSet , or ObjC NS_OPTIONS . Records are pure-data value objects. Interfaces are objects with defined methods to call (in C++, passed by shared_ptr ). Djinni produces code allowing an interface implemented in C++ to be transparently used from ObjC or Java, and vice versa.","title":"Types"},{"location":"djinni-generator/idl/#enums","text":"my_enum = enum { option1; option2; option3; } Enums are translated to C++ enum class es with underlying type int , ObjC NS_ENUM s with underlying type NSInteger , and Java enums.","title":"Enums"},{"location":"djinni-generator/idl/#flags","text":"my_flags = flags { flag1; flag2; flag3; no_flags = none; all_flags = all; } Flags are translated to C++ enum class es with underlying type unsigned and a generated set of overloaded bitwise operators for convenience, ObjC NS_OPTIONS with underlying type NSUInteger , and Java EnumSet<> . Contrary to the above enums, the enumerants of flags represent single bits instead of integral values. In the above example the elements marked with none and all are given special meaning. In C++ and ObjC the no_flags option is generated with a value that has no bits set (i.e. 0 ), and all_flags is generated as a bitwise-or combination of all other values. In Java these special options are not generated as one can just use EnumSet.noneOf() and EnumSet.allOf() .","title":"Flags"},{"location":"djinni-generator/idl/#records","text":"my_record = record { id: i32; info: string; store: set<string>; hash: map<string, i32>; values: list<another_record>; # Comments can also be put here # Constants can be included const string_const: string = \"Constants can be put here\"; const min_value: another_record = { key1 = 0, key2 = \"\" }; } Records are data objects. In C++, records contain all their elements by value, including other records (so a record cannot contain itself).","title":"Records"},{"location":"djinni-generator/idl/#extensions","text":"To support extra fields and/or methods, a record can be \"extended\" in any language. To extend a record in a language, you can add a +c (C++), +j (Java), or +o (ObjC) flag after the record tag. The generated type will have a Base suffix, and you should create a derived type without the suffix that extends the record type. The derived type must be constructible in the same way as the Base type. Interfaces will always use the derived type.","title":"Extensions"},{"location":"djinni-generator/idl/#derived-methods","text":"another_record = record { key1: i32; key2: string; } deriving (eq, ord) For record types, Haskell-style \"deriving\" declarations are supported to generate some common methods. Djinni is capable of generating equality and order comparators, implemented as operator overloading in C++ and standard comparison functions in Java / Objective-C. Note All fields in the record are compared in the order they appear in the record declaration. If you need to add a field later, make sure the order is correct. Ordering comparison is not supported for collection types, optionals, and booleans. To compare records containing other records, the inner record must derive at least the same types of comparators as the outer record.","title":"Derived methods"},{"location":"djinni-generator/idl/#interfaces","text":"# This interface will be implemented in C++ and can be called from any language. my_cpp_interface = interface +c { method_returning_nothing(value: i32); method_returning_some_type(key: string): another_record; static get_version(): i32; # Interfaces can also have constants const version: i32 = 1; } # This interface will be implemented in Java and ObjC and can be called from C++. my_client_interface = interface +j +o { log_string(str: string): bool; } Interfaces are objects with defined methods to call (in C++, passed by shared_ptr ). Djinni produces code allowing an interface implemented in C++ to be transparently used from ObjC or Java, and vice versa.","title":"Interfaces"},{"location":"djinni-generator/idl/#special-methods-for-c-only","text":"+c interfaces (implementable only in C++) can have methods flagged with the special keywords const and static which have special effects in C++: special_methods = interface +c { const accessor_method(); static factory_method(); } const methods will be declared as const in C++, though this cannot be enforced on callers in other languages, which lack this feature. static methods will become a static method of the C++ class, which can be called from other languages without an object. This is often useful for factory methods to act as a cross-language constructor.","title":"Special Methods for C++ Only"},{"location":"djinni-generator/idl/#exception-handling","text":"When an interface implemented in C++ throws a std::exception , it will be translated to a java.lang.RuntimeException in Java or an NSException in Objective-C. The what() message will be translated as well.","title":"Exception Handling"},{"location":"djinni-generator/idl/#constants","text":"Constants can be defined within interfaces and records. In Java and C++ they are part of the generated class; and in Objective-C, constant names are globals with the name of the interface/record prefixed. Example: record_with_const = record +c +j +o { const const_value: i32 = 8; } will be RecordWithConst::CONST_VALUE in C++, RecordWithConst.CONST_VALUE in Java, and RecordWithConstConstValue in Objective-C.","title":"Constants"},{"location":"djinni-generator/idl/#comments","text":"# This is a comment If comments are are placed on top or inside a type definition , they will be converted to Javadoc / Doxygen compatible comments in the generated Java/C++/Objective-C interfaces.","title":"Comments"},{"location":"djinni-generator/setup/","text":"Generator Setup \u00b6 Installation \u00b6 Important The generator requires Java ! Linux, macOS \u00b6 Download & Install Manually \u00b6 Download the lastest released binary , make it executable and put the containing folder on your PATH: curl -LO https://github.com/cross-language-cpp/djinni-generator/releases/latest/download/djinni chmod u+x djinni export PATH = $( pwd ) : $PATH Make sure to put it on your PATH permanently once you fell in love with djinni! Install with asdf \u00b6 asdf plugin add djinni asdf install djinni latest Windows \u00b6 Download the latest released batch file , copy it where you want and put the folder on your PATH .","title":"Generator Setup"},{"location":"djinni-generator/setup/#generator-setup","text":"","title":"Generator Setup"},{"location":"djinni-generator/setup/#installation","text":"Important The generator requires Java !","title":"Installation"},{"location":"djinni-generator/setup/#linux-macos","text":"","title":"Linux, macOS"},{"location":"djinni-generator/setup/#download-install-manually","text":"Download the lastest released binary , make it executable and put the containing folder on your PATH: curl -LO https://github.com/cross-language-cpp/djinni-generator/releases/latest/download/djinni chmod u+x djinni export PATH = $( pwd ) : $PATH Make sure to put it on your PATH permanently once you fell in love with djinni!","title":"Download &amp; Install Manually"},{"location":"djinni-generator/setup/#install-with-asdf","text":"asdf plugin add djinni asdf install djinni latest","title":"Install with asdf"},{"location":"djinni-generator/setup/#windows","text":"Download the latest released batch file , copy it where you want and put the folder on your PATH .","title":"Windows"},{"location":"djinni-intellij-plugin/about/","text":"About IntelliJ IDEA Plugin \u00b6 Adds basic navigation, code-completion and error highlighting support for .djinni IDL files. Get the plugin in the Jetbrains Marketplace:","title":"About IntelliJ IDEA Plugin"},{"location":"djinni-intellij-plugin/about/#about-intellij-idea-plugin","text":"Adds basic navigation, code-completion and error highlighting support for .djinni IDL files. Get the plugin in the Jetbrains Marketplace:","title":"About IntelliJ IDEA Plugin"},{"location":"djinni-intellij-plugin/developer-guide/","text":"Developer Guide \u00b6 Info This chapter is only interesting if you intend to make changes to the code of djinni generator Development Basics \u00b6 Build \u00b6 To build on your local machine, run the buildPlugin task ./gradlew buildPlugin Debug \u00b6 With the runIde task you can run the plugin in an isolated IDE and get logs about whats going on. Install \u00b6 To install the plugin you just built locally, go to Preferences > Plugins > Marketplace > \u2699 > Install plugin from disk... You can find the built plugin package under build/distributions/djinni-intellij-plugin-<version>.zip Adjusting grammar \u00b6 The grammar for .djinni files is defined in Backus\u2013Naur form in Djinni.bnf If you decide to make changes to this file, the following manual steps are required to apply them: - Djinni.bnf : - Right-Click > Generate Parser Code - Right-Click > Generate JFlex Lexer , in the file dialog click Save and Replace - _DjinniLexer.flex : - Right-Click > Run JFlex Generator Release process \u00b6 To release a new plugin version, the following steps must be followed: 1. Create a new release-tag. Set a meaningful version number and describe what has changed in the new version. 2. Wait. Github will automatically build the plugin, publish it to the jetbrains marketplace & upload the plugin-artifact to the release. 3. The update will be verified by Jetbrains within a few days. Then it will be distributed to the users. That's it :)","title":"Developer Guide"},{"location":"djinni-intellij-plugin/developer-guide/#developer-guide","text":"Info This chapter is only interesting if you intend to make changes to the code of djinni generator","title":"Developer Guide"},{"location":"djinni-intellij-plugin/developer-guide/#development-basics","text":"","title":"Development Basics"},{"location":"djinni-intellij-plugin/developer-guide/#build","text":"To build on your local machine, run the buildPlugin task ./gradlew buildPlugin","title":"Build"},{"location":"djinni-intellij-plugin/developer-guide/#debug","text":"With the runIde task you can run the plugin in an isolated IDE and get logs about whats going on.","title":"Debug"},{"location":"djinni-intellij-plugin/developer-guide/#install","text":"To install the plugin you just built locally, go to Preferences > Plugins > Marketplace > \u2699 > Install plugin from disk... You can find the built plugin package under build/distributions/djinni-intellij-plugin-<version>.zip","title":"Install"},{"location":"djinni-intellij-plugin/developer-guide/#adjusting-grammar","text":"The grammar for .djinni files is defined in Backus\u2013Naur form in Djinni.bnf If you decide to make changes to this file, the following manual steps are required to apply them: - Djinni.bnf : - Right-Click > Generate Parser Code - Right-Click > Generate JFlex Lexer , in the file dialog click Save and Replace - _DjinniLexer.flex : - Right-Click > Run JFlex Generator","title":"Adjusting grammar"},{"location":"djinni-intellij-plugin/developer-guide/#release-process","text":"To release a new plugin version, the following steps must be followed: 1. Create a new release-tag. Set a meaningful version number and describe what has changed in the new version. 2. Wait. Github will automatically build the plugin, publish it to the jetbrains marketplace & upload the plugin-artifact to the release. 3. The update will be verified by Jetbrains within a few days. Then it will be distributed to the users. That's it :)","title":"Release process"},{"location":"djinni-support-lib/install/","text":"Installing the Support-Lib \u00b6 conan \u00b6 TODO hunter \u00b6 TODO","title":"Installing the Support-Lib"},{"location":"djinni-support-lib/install/#installing-the-support-lib","text":"","title":"Installing the Support-Lib"},{"location":"djinni-support-lib/install/#conan","text":"TODO","title":"conan"},{"location":"djinni-support-lib/install/#hunter","text":"TODO","title":"hunter"}]}